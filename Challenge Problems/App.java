/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package hw4;


public class App {

    public static final Double EPSILON = 1e-8;

    /**
     * Returns the length of the longest common subsequence between x and y.
     *
     * @param x array containing Integers.
     * @param y array containing Integers.
     * @return The length of the longest common subsequence between x and y.
     */
    public static Integer LCS(Integer[] x, Integer[] y) {
        int m = x.length;
        int n = y.length;
        int[][] sol = new int[2][n+1];
        for (int i = 0; i < 2; i++) {
            sol[i][0] = 0;
        }
        for (int j = 0; j <= n; j++) {
            sol[0][j] = 0;
        }
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (x[i-1] == y[j-1]) {
                    sol[1][j] = 1 + sol[0][j-1];
                } else {
                    sol[1][j] = Math.max(sol[0][j], sol[1][j - 1]);
                }
            }
            sol[0] = sol[1];
        }
        return sol[1][n];
    }

    /**
     * Returns the length of the longest palindromic sequence in x. For example, the
     * following two arrays have the same longest palindromic sequence of {1, 2, 1}:
     *
     *     [1, 5, 2, 7, 7, 1]
     *     [0, 1, 2, 1, 8]
     *
     * In other words, the components of the palindromic sequence need not be adjacent
     * to eachtother, the only requirement is that the sequence forms a palindrom.
     *
     * A palindrome is a word/pattern that is the same when it is reversed (e.g.,
     * the word "racecar" or the sequence {1, 2, 1}.
     *
     * @param x array of Integers.
     * @return the longest palindrome contained in x.
     */
    public static Integer LongestPalindrome(Integer[] x) {
        int n = x.length;
        if (n == 0) return 0;
        int[][] sol = new int[n][n];
        for (int i = 0; i < n; i++) {
            sol[i][i] = 1;
        }
        for (int size = 2; size <= n; size++) {
            for (int i = 0; i <= n - size; i++) {
                int j = i + size - 1;
                if(x[i] == x[j] && size == 2) {
                    sol[i][j] = 2;
                } else if (x[i] == x[j]) {
                    sol[i][j] = 2 + sol[i + 1][j - 1];
                } else {
                    sol[i][j] = Math.max(sol[i + 1][j], sol[i][j - 1]);
                }
            }
        }
        return sol[0][n-1];
    }

    /**
     * Return the maximum value that can be stored in the knapsack.
     *
     * @param weights array containing the weights of each object.
     * @param values array containing the value of each object.
     * @param capacity the max weight the knapsack can store.
     * @return the maximum value that can be stored in the knapsack under the assumption that
     *         objects can be divided with arbitrary precision.
     */
    public static Double FractionalKnapsack(Double[] weights, Double[] values, Double capacity) {
        int n = Math.min(weights.length, values.length);
        if (n == 0) return 0.0;
        Double sol = 0.0;
        Double[] v = new Double[n];
        for (int i = 0; i < n; i++) {
            v[i] = values[i] / weights[i];
        }
        while (capacity > 0) {
            int max = 0;
            for (int i = 0; i < n; i++) {
                if (v[i] > v[max]) {
                    max = i;
                }
            }
            if (v[max] == 0.0) break;
            Double toTake = Math.min(capacity, weights[max]);
            sol += toTake * v[max];
            capacity -= toTake;
            v[max] = 0.0;
        }
        return sol;
    }

    /**
     * Return the maximum number of activities that can be scheduled with the given start and finish times.
     * Note: you may assume the activity times are sorted by finish time.
     *
     * @param startTimes array containing the start times of each activity. Element i corresponds to the
     *        start time of activity i.
     * @param finishTimes array containing the finish times of each activity. Element i corresponds to the
     *        finish time of activity i.
     * @return An Integer representing the maximum number of compatible activities.
     */
    public static Integer MaxScheduling(Integer[] startTimes, Integer[] finishTimes) {
	    int n = startTimes.length;
	    if (n == 0) return 0;
	    int sol = 1;
	    int j = 0;
	    for (int i = 1; i < n; i++) {
	        if (startTimes[i] >= finishTimes[j]) {
	            sol++;
	            j = i;
            }
        }
	    return sol;
    }

    public static void main(String[] args) {
    }
}
